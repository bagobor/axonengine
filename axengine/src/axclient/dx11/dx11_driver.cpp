#include "dx11_private.h"

AX_BEGIN_NAMESPACE

AX_IMPLEMENT_FACTORY(DX11_Driver)

// console command
AX_BEGIN_COMMAND_MAP(DX11_Driver)
AX_END_COMMAND_MAP()

typedef HRESULT (WINAPI *LPD3D11CREATEDEVICE)(IDXGIAdapter*, D3D_DRIVER_TYPE, HMODULE, UINT32, D3D_FEATURE_LEVEL*, UINT, UINT32, ID3D11Device**, D3D_FEATURE_LEVEL*, ID3D11DeviceContext**);
static HMODULE s_hModD3D11 = 0;
static LPD3D11CREATEDEVICE s_DynamicD3D11CreateDevice = 0;

DX11_Driver::DX11_Driver()
{

}

DX11_Driver::~DX11_Driver()
{

}

void DX11_Driver::initialize(SyncEvent &syncEvent)
{
	// This may fail if Direct3D 11 isn't installed
	s_hModD3D11 = LoadLibraryW(L"d3d11.dll");
	if (s_hModD3D11) {
		s_DynamicD3D11CreateDevice = (LPD3D11CREATEDEVICE)GetProcAddress(s_hModD3D11, "D3D11CreateDevice");
	}

	if (!s_hModD3D11 || !s_DynamicD3D11CreateDevice)
		return;

	D3D_FEATURE_LEVEL featureLevel;
	HRESULT hr = s_DynamicD3D11CreateDevice(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, 0, 0, &dx11_device, &featureLevel, &dx11_context);
}

void DX11_Driver::finalize()
{

}

const ShaderInfo * DX11_Driver::findShaderInfo( const FixedString &key )
{
	return 0;
}

namespace {
	const D3D11_INPUT_ELEMENT_DESC s_ilSkin[] =
	{
		{"POSITION",  0, DXGI_FORMAT_R32G32B32_FLOAT,    0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"COLOR",     0, DXGI_FORMAT_R8G8B8A8_UNORM,     0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"TEXCOORD",  0, DXGI_FORMAT_R32G32_FLOAT,       0, 16, D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"TEXCOORD",  1, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"TEXCOORD",  2, DXGI_FORMAT_R32G32B32_FLOAT,    0, 40, D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"TEXCOORD",  3, DXGI_FORMAT_R32G32B32_FLOAT,    0, 52, D3D11_INPUT_PER_VERTEX_DATA, 0},
	};

	const D3D11_INPUT_ELEMENT_DESC s_ilMesh[] =
	{
		{"POSITION",  0, DXGI_FORMAT_R32G32B32_FLOAT,    0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"COLOR",     0, DXGI_FORMAT_R8G8B8A8_UNORM,     0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"TEXCOORD",  0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 16, D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"TEXCOORD",  1, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 32, D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"TEXCOORD",  2, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 48, D3D11_INPUT_PER_VERTEX_DATA, 0},
	};

	const D3D11_INPUT_ELEMENT_DESC s_ilDebug[] =
	{
		{"POSITION",  0, DXGI_FORMAT_R32G32B32_FLOAT,    0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"COLOR",     0, DXGI_FORMAT_R8G8B8A8_UNORM,     0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0},
	};

	const D3D11_INPUT_ELEMENT_DESC s_ilBlend[] =
	{
		{"POSITION",  0, DXGI_FORMAT_R32G32B32_FLOAT,    0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"COLOR",     0, DXGI_FORMAT_R8G8B8A8_UNORM,     0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0},
		{"TEXCOORD",  0, DXGI_FORMAT_R32G32_FLOAT,       0, 16, D3D11_INPUT_PER_VERTEX_DATA, 0},
	};

	const D3D11_INPUT_ELEMENT_DESC s_ilChunk[] =
	{
		{"POSITION",  0, DXGI_FORMAT_R32G32B32_FLOAT,    0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0},
	};

	const D3D11_INPUT_ELEMENT_DESC s_ilInstance[] =
	{
		{"TEXCOORD",  4, DXGI_FORMAT_R32G32_FLOAT,       1, 0,  D3D11_INPUT_PER_INSTANCE_DATA, 1},
		{"TEXCOORD",  5, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 16, D3D11_INPUT_PER_INSTANCE_DATA, 1},
		{"TEXCOORD",  6, DXGI_FORMAT_R32G32B32_FLOAT,    1, 32, D3D11_INPUT_PER_INSTANCE_DATA, 1},
		{"TEXCOORD",  7, DXGI_FORMAT_R32G32B32_FLOAT,    1, 48, D3D11_INPUT_PER_INSTANCE_DATA, 1},
	};

}

void DX11_Driver::createInputLayouts()
{

}

AX_END_NAMESPACE
